{
  "hash": "a6467bacb0f43dc0b3820655dd2084e6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code with `data.table`: Week One\"\nauthor: \"Kelly Bodwin\"\ndate: \"2024-12-07\"\ncategories: [tutorials, community]\nimage: \"aoc2.png\"\ndraft: false\n---\n\n\n\n\nHappy December, R friends!\n\nOne of my favorite traditions in the R community is the [Advent of Code](https://adventofcode.com/), a series of puzzles released at midnight EST from December 1st through 25th, to be solved through programming in the language of your choosing. I usually do a few of them each year, and once tried to do every single one at the moment it released!\n\n![](aoc.png)\n\nThis year, I know I won't be able to do it daily, but I'm going to do as many as I can using just `data.table` solutions.\n\nI'll allow myself to use other packages when there isn't any `data.table` equivalent, but my solutions must be as `data.table`-y as possible.\n\nI'm going to abuse the blog post structure and update this file throughout the week.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\n```\n:::\n\n\n\n\n### December 1st\n\n#### Part One\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- fread(\"day1_dat1.txt\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd1[, V1 := sort(V1)]\nd1[, V2 := sort(V2)]\nd1[, diff := abs(V1-V2)]\n\nsum(d1$diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2815556\n```\n\n\n:::\n:::\n\n\n\n\n#### Part Two\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1[, similarity := sum(V1 == d1$V2)*V1, by = V1]\n\nsum(d1$similarity)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23927637\n```\n\n\n:::\n:::\n\n\n\n\n### December 2nd\n\n#### Part One\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- fread(\"day2_dat1.txt\", fill = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_report <- function(vec) {\n  \n  vec <- na.omit(vec)\n  \n  has_neg <- vec < 0\n  has_pos <- vec > 0\n  \n  inc_dec <- sum(has_neg) == length(vec) | sum(has_pos) == length(vec)\n\n  too_big <- max(abs(vec)) > 3\n  \n  return(inc_dec & !too_big)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd1t <- transpose(d1)\ndeltas <- d1t[-nrow(d1t)] - d1t[2:nrow(d1t)]\n\nres <- apply(deltas, 2, \"check_report\")\n\nsum(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 479\n```\n\n\n:::\n:::\n\n\n\n\n#### Part Two\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_reports <- function(dat) {\n\n  deltas <- dat[-nrow(dat)] - dat[2:nrow(dat)]\n\n  res <- apply(deltas, 2, \"check_report\")\n\n  res\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- test_reports(d1t)\n\nfor (i in 1:nrow(d1t)) {\n  \n  res <- res | test_reports(d1t[-i,])\n  \n  \n}\n\nsum(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 531\n```\n\n\n:::\n:::\n\n\n\n\n#### Just for fun\n\nI found the use of `apply` deeply unsatisfying, even though it was fast, so just for fun:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1t <- transpose(d1)\ndeltas <- d1t[-nrow(d1t)] - d1t[2:nrow(d1t)]\n\nis_not_pos <- deltas <= 0\nis_not_neg <- deltas >= 0\nis_big <- abs(deltas) > 3\n\nres_inc <- colSums(is_not_neg | is_big, na.rm = TRUE)\n\nres_dec <- colSums(is_not_pos | is_big, na.rm = TRUE)\n\nsum(res_inc == 0) + sum(res_dec == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 479\n```\n\n\n:::\n:::\n\n\n\n\nYay. :)\n\n### December 3rd-7th\n\nNothing `data.table`-y in this one; you can see my solution [here](https://github.com/kbodwin/Advent_of_Code/blob/master/2024/day3.R) if you want.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}