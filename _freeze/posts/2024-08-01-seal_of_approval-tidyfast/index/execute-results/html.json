{
  "hash": "3d25b5cff09f5080b6ec669ee334126f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Seal of Approval: tidyfast\"\nauthor: \"Tyson S. Barrett\"\ndate: \"Aug 01, 2024\"\ncategories: [seal of approval, bridge package]\nimage: \"hex_approved.png\"\ndraft: false\n---\n\n\n## [`tidyfast`](https://github.com/TysonStanley/tidyfast)\n\n::: columns\n::: {.column width=\"40%\"}\n![`tidyfast` hex sticker](hex.png)\n:::\n\n::: {.column width=\"60%\"}\n*Author(s):* Tyson S. Barrett, Mark Fairbanks, Ivan Leung, Indrajeet Patil\n\n*Maintainer:* Tyson S. Barrett ([t.barrett88\\@gmail.com](mailto:t.barrett88@gmail.com){.email})\n\n[Seal of Approval](github.com)\n\nThe goal of `tidyfast` is to provide fast and efficient alternatives to some `tidyr` (and a few `dplyr`) functions using `data.table` under the hood. Each have the prefix of `dt_` to allow for autocomplete in IDEs such as RStudio. These should compliment some of the current functionality in `dtplyr` (but notably does not use the `lazy_dt()` framework of `dtplyr`). This package imports `data.table` and `cpp11` (no other dependencies). These are, in essence, translations from a more tidyverse grammar to `data.table`. Most functions herein are in places where, in my opinion, the `data.table` syntax is not obvious or clear. As such, these functions can translate a simple function call into the fast, efficient, and concise syntax of data.table.\n:::\n:::\n\n## Relationship with `data.table`\n\n`tidyfast` was designed to be an extension to and translation of `data.table`. As such, there are three main ways `tidyfast` is related to `data.table`.\n\n1.  This package is built directly on `data.table` using direct calls to `[.data.table` and other functions under the hood.\n2.  It only relies on two packages, `cpp11` and `data.table` both stable packages that are unlikely to have breaking changes often. This follows the `data.table` principle of few dependencies.\n3.  It was designed to also show how others can use `data.table` within their own package to create functions that flexibly call `data.table` in complex ways.\n\n## Overview\n\nAs shown on the `tidyfast` GitHub page, `tidyfast` has several functions that have the prefix `dt_`. A few notable functions from the package are shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyfast)\nlibrary(data.table)\nlibrary(magrittr)\n```\n:::\n\n\n### dt_fill\n\nFilling NAs is a useful function but `tidyr::fill()`, especially when done by many, many groups can become too slow. `dt_fill()` is useful for this and can be used a few different ways.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 1:10\ndt_with_nas <- data.table(\n  x = x,\n  y = shift(x, 2L),\n  z = shift(x, -2L),\n  a = sample(c(rep(NA, 10), x), 10),\n  id = sample(1:3, 10, replace = TRUE)\n)\n\n# Original\ndt_with_nas\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        x     y     z     a    id\n    <int> <int> <int> <int> <int>\n 1:     1    NA     3     6     1\n 2:     2    NA     4     1     1\n 3:     3     1     5     7     3\n 4:     4     2     6    NA     3\n 5:     5     3     7    NA     3\n 6:     6     4     8    NA     3\n 7:     7     5     9    NA     1\n 8:     8     6    10     8     3\n 9:     9     7    NA    NA     1\n10:    10     8    NA     2     2\n```\n\n\n:::\n\n```{.r .cell-code}\n# All defaults\ndt_fill(dt_with_nas, y, z, a, immutable = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        x     y     z     a    id\n    <int> <int> <int> <int> <int>\n 1:     1    NA     3     6     1\n 2:     2    NA     4     1     1\n 3:     3     1     5     7     3\n 4:     4     2     6     7     3\n 5:     5     3     7     7     3\n 6:     6     4     8     7     3\n 7:     7     5     9     7     1\n 8:     8     6    10     8     3\n 9:     9     7    10     8     1\n10:    10     8    10     2     2\n```\n\n\n:::\n\n```{.r .cell-code}\n# by id variable called `grp`\ndt_fill(dt_with_nas, \n        y, z, a, \n        id = list(id))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        x     y     z     a    id\n    <int> <int> <int> <int> <int>\n 1:     1    NA     3     6     1\n 2:     2    NA     4     1     1\n 3:     3     1     5     7     3\n 4:     4     2     6     7     3\n 5:     5     3     7     7     3\n 6:     6     4     8     7     3\n 7:     7     5     9     7     1\n 8:     8     6    10     8     3\n 9:     9     7    10     8     1\n10:    10     8    10     2     2\n```\n\n\n:::\n\n```{.r .cell-code}\n# both down and then up filling by group\ndt_fill(dt_with_nas, \n        y, z, a, \n        id = list(id), \n        .direction = \"downup\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        x     y     z     a    id\n    <int> <int> <int> <int> <int>\n 1:     1     5     3     6     1\n 2:     2     5     4     1     1\n 3:     3     1     5     7     3\n 4:     4     2     6     7     3\n 5:     5     3     7     7     3\n 6:     6     4     8     7     3\n 7:     7     5     9     7     1\n 8:     8     6    10     8     3\n 9:     9     7    10     8     1\n10:    10     8    10     2     2\n```\n\n\n:::\n:::\n\n\n### dt_nest\n\nNesting data can be useful for a number of reasons, including XX. The `dt_nest()` function takes a `data.table` and ID variables and nests the remaining columns into a list column of `data.table`s as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- data.table(\n   x = rnorm(1e5),\n   y = runif(1e5),\n   grp = sample(1L:5L, 1e5, replace = TRUE),\n   nested1 = lapply(1:10, sample, 10, replace = TRUE),\n   nested2 = lapply(c(\"thing1\", \"thing2\"), sample, 10, replace = TRUE),\n   id = 1:1e5\n)\n\nnested <- dt_nest(dt, grp)\nnested\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nKey: <grp>\n     grp                  data\n   <int>                <list>\n1:     1 <data.table[19893x5]>\n2:     2 <data.table[20130x5]>\n3:     3 <data.table[19951x5]>\n4:     4 <data.table[20062x5]>\n5:     5 <data.table[19964x5]>\n```\n\n\n:::\n:::\n\n\n### dt_pivot_longer and dt_pivot_wider\n\nThe last example for this brief post is pivoting. In my opinion, the pivot syntax is easy to remember and use and as such, is nice to have that syntax with the performance of `melt()` and `dcast()`. The syntax, although it doesn't have the full functionality of `tidyr`'s pivot functions, can do most things you need to do with reshaping data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbillboard <- tidyr::billboard \n\nlonger <- billboard %>%\n  dt_pivot_longer(\n     cols = c(-artist, -track, -date.entered),\n     names_to = \"week\",\n     values_to = \"rank\"\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in melt.data.table(data = dt_, id.vars = id_vars, measure.vars = cols,\n: 'measure.vars' [wk1, wk2, wk3, wk4, ...] are not all of the same type. By\norder of hierarchy, the molten data value column will be of type 'double'. All\nmeasure variables not of type 'double' will be coerced too. Check DETAILS in\n?melt.data.table for more on coercion.\n```\n\n\n:::\n\n```{.r .cell-code}\nlonger\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                 artist                   track date.entered   week  rank\n                 <char>                  <char>       <Date> <char> <num>\n    1:            2 Pac Baby Don't Cry (Keep...   2000-02-26    wk1    87\n    2:          2Ge+her The Hardest Part Of ...   2000-09-02    wk1    91\n    3:     3 Doors Down              Kryptonite   2000-04-08    wk1    81\n    4:     3 Doors Down                   Loser   2000-10-21    wk1    76\n    5:         504 Boyz           Wobble Wobble   2000-04-15    wk1    57\n   ---                                                                   \n24088:      Yankee Grey    Another Nine Minutes   2000-04-29   wk76    NA\n24089: Yearwood, Trisha         Real Live Woman   2000-04-01   wk76    NA\n24090:  Ying Yang Twins Whistle While You Tw...   2000-03-18   wk76    NA\n24091:    Zombie Nation           Kernkraft 400   2000-09-02   wk76    NA\n24092:  matchbox twenty                    Bent   2000-04-29   wk76    NA\n```\n\n\n:::\n:::\n\n\nCan also take that long data set and turn it wide again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwider <- longer %>% \n  dt_pivot_wider(\n    names_from = week,\n    values_from = rank\n  )\nwider[, .(artist, track, wk1, wk2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               artist                   track   wk1   wk2\n               <char>                  <char> <num> <num>\n  1:            2 Pac Baby Don't Cry (Keep...    87    82\n  2:          2Ge+her The Hardest Part Of ...    91    87\n  3:     3 Doors Down              Kryptonite    81    70\n  4:     3 Doors Down                   Loser    76    76\n  5:         504 Boyz           Wobble Wobble    57    34\n ---                                                     \n313:      Yankee Grey    Another Nine Minutes    86    83\n314: Yearwood, Trisha         Real Live Woman    85    83\n315:  Ying Yang Twins Whistle While You Tw...    95    94\n316:    Zombie Nation           Kernkraft 400    99    99\n317:  matchbox twenty                    Bent    60    37\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}