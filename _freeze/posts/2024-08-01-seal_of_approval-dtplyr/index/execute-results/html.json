{
  "hash": "7b67bebe58e43a1de1ad2b0c696ff587",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Seal of Approval: dtplyr\"\nauthor: \"Kelly Bodwin\"\ndate: \"Aug 01, 2024\"\ncategories: [seal of approval, bridge package]\nimage: \"hex_approved.png\"\ndraft: false\n---\n\n\n## [`dtplyr`](https://github.com/tidyverse/dtplyr)\n\n::::{.columns}\n\n:::{.column width=\"40%\"}\n\n![dtplyr hex sticker](hex.png)\n:::\n\n\n:::{.column width=\"60%\"}\n\n*Author(s):*\tHadley Wickham, Maximilian Girlich, Mark Fairbanks, Ryan Dickerson, Posit Software PBC\n\n*Maintainer:*\tHadley Wickham (hadley\\@posit.co)\n\n\nProvides a `data.table` backend for `dplyr`. The goal of `dtplyr` is to allow you to write `dplyr` code that is automatically translated to the equivalent, but usually much faster, `data.table` code.\n\n:::\n\n::::\n\n## Relationship with `data.table`\n\n`dtplyr` is a bridge for users who are more comfortable with the `dplyr` syntax, but who want to take advantage of the speed and efficiency benefits of `data.table`.  This package exactly duplicates the core functions of `dplyr`, but replaces the back-end source code (originally in Base R) with `data.table` operations.\n\n## Overview\n\n*Excerpted from the [`dtplyr` vignette](https://dtplyr.tidyverse.org/)*\n\nTo use `dtplyr`, you must at least load `dtplyr` and `dplyr`. You may also want to load `data.table` so you can access the other goodies that it provides:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\nlibrary(dtplyr)\nlibrary(dplyr, warn.conflicts = FALSE)\n```\n:::\n\n\n\nThen use `lazy_dt()` to create a “lazy” `data.table` object that tracks the operations performed on it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars2 <- lazy_dt(mtcars)\n```\n:::\n\n\nYou can preview the transformation (including the generated `data.table` code) by printing the result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars2 %>% \n  filter(wt < 5) %>% \n  mutate(l100k = 235.21 / mpg) %>% # liters / 100 km\n  group_by(cyl) %>% \n  summarise(l100k = mean(l100k))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSource: local data table [3 x 2]\nCall:   `_DT1`[wt < 5][, `:=`(l100k = 235.21/mpg)][, .(l100k = mean(l100k)), \n    keyby = .(cyl)]\n\n    cyl l100k\n  <dbl> <dbl>\n1     4  9.05\n2     6 12.0 \n3     8 14.9 \n\n# Use as.data.table()/as.data.frame()/as_tibble() to access results\n```\n\n\n:::\n:::\n\n\nBut generally you should reserve this only for debugging, and use `as.data.table()`, `as.data.frame()`, or `as_tibble()` to indicate that you’re done with the transformation and want to access the results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars2 %>% \n  filter(wt < 5) %>% \n  mutate(l100k = 235.21 / mpg) %>% # liters / 100 km\n  group_by(cyl) %>% \n  summarise(l100k = mean(l100k)) %>% \n  as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n    cyl l100k\n  <dbl> <dbl>\n1     4  9.05\n2     6 12.0 \n3     8 14.9 \n```\n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}