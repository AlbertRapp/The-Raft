{
  "hash": "db881de76734683961b4a03266bb9a78",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Seal of Approval: nc\"\nauthor: \"Toby Dylan Hocking\"\ndate: \"Aug 01, 2024\"\ncategories: [seal of approval, extension package]\nimage: \"hex_approved.png\"\ndraft: false\n---\n\n\n## [`nc`](https://github.com/tdhock/nc)\n\n::: columns\n::: {.column width=\"40%\"}\n\n![`nc` hex sticker](hex.png)\n\n:::\n\n::: {.column width=\"60%\"}\n\n*Maintainer:* Toby Dylan Hocking (toby.hocking\\@r-project.org)\n\n\nUser-friendly functions for extracting a data table (row for each match, column for each group) from non-tabular text data using regular expressions, and for melting columns that match a regular expression. Patterns are defined using a readable syntax that makes it easy to build complex patterns in terms of simpler, re-usable sub-patterns. Named R arguments are translated to column names in the output, thereby providing a standard interface to three regular expression 'C' libraries ('PCRE', 'RE2', 'ICU'). Output can also include numeric columns via user-specified type conversion functions.\n\n:::\n::::\n\n## Relationship with `data.table`\n\nWhereas `data.table` provides several functions such as `patterns()` and `measure()` which support some regex engines (PCRE, TRE), `nc` interfaces with two other engines (RE2, ICU). `nc` imports `data.table`, and always returns regex match results as a `data.table`.\n\n## Overview\n\n`nc` is useful for extracting numeric data from text, for example consider the following strings, which indicate genomic positions, in bases on a chromosome:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchr.pos.vec <- c(\n  \"chr10:213,054,000-213,055,000\",\n  \"chrM:111,000\",              # no end.\n  \"chr1:110-111 chr2:220-222\") # two ranges.\n```\n:::\n\n\nThe data above consist of a chromosome name (chr10), followed by a start position, and then optionally a dash and an end position. Using `nc`, we can extract these different pieces of information into a data table using the code below, which inputs the data to parse (first argument), along with a regular expression (subsequent arguments).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc::capture_first_vec(\n  chr.pos.vec,\n  chrom=\"chr.*?\",\n  \":\",\n  start=\"[0-9,]+\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    chrom       start\n   <char>      <char>\n1:  chr10 213,054,000\n2:   chrM     111,000\n3:   chr1         110\n```\n\n\n:::\n:::\n\n\nThe code above uses `chrom` and `start` as argument names, which are therefore used for column names in the output data table (one row per input subject string, one column per named argument / capture group). However the code above only parses the start position (and not the optional end position). Below, we create a more complex regex to parse both the start and end, by first defining a common pattern to parse an integer,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkeep.digits <- function(x) as.integer(gsub(\"[^0-9]\", \"\", x))\n\nint.pattern <- list(\"[0-9,]+\", keep.digits)\n```\n:::\n\n\nIn the code above, we use a list to group the regex `\"[0-9],]+\"` with the function `keep.digits` which will be used for parsing the text that is extracted by that regex. We use that pattern twice in the code below,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange.pattern <- list(\n  chrom=\"chr.*?\",\n  \":\",\n  start=int.pattern,\n  list( # un-named list becomes non-capturing group.\n    \"-\",\n    end=int.pattern\n  ), \"?\") # chromEnd is optional.\nnc::capture_first_vec(chr.pos.vec, range.pattern)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    chrom     start       end\n   <char>     <int>     <int>\n1:  chr10 213054000 213055000\n2:   chrM    111000        NA\n3:   chr1       110       111\n```\n\n\n:::\n:::\n\n\nThe result above is a data table containing the first match in each subject (three rows total). Note the second row has `end=NA` because that optional group did not match.\n\nBut the last subject has two potential matches (only the first is reported above). What if we wanted to get all matches in each subject? We can use another function, as in the code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc::capture_all_str(chr.pos.vec, range.pattern)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    chrom     start       end\n   <char>     <int>     <int>\n1:  chr10 213054000 213055000\n2:   chrM    111000        NA\n3:   chr1       110       111\n4:   chr2       220       222\n```\n\n\n:::\n:::\n\n\nThe output above includes all matches in each subject (four rows total), but does not include any information about which subject each row came from, because it treats the subject as a single string to parse. To get that info, we can use `capture_all_str()` for each row, using `by=.I` as in the code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\ndata.table(chr.pos.vec)[, nc::capture_all_str(\n  chr.pos.vec, range.pattern), by=.I]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       I  chrom     start       end\n   <int> <char>     <int>     <int>\n1:     1  chr10 213054000 213055000\n2:     2   chrM    111000        NA\n3:     3   chr1       110       111\n4:     3   chr2       220       222\n```\n\n\n:::\n:::\n\n\nThe output above includes the additional `I` column which is the index of the subject that each match came from (two rows with `I=3` because there are two matches in the third subject).\n\nFinally, `data.table::melt()` is used to power the long-to-wide data reshaping functionality in `nc`. In `data.table` we could use `measure()` to specify a set of variables to reshape, as in the code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(iris.wide <- data.table(iris)[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <num>       <num>        <num>       <num>  <fctr>\n1:          5.1         3.5          1.4         0.2  setosa\n```\n\n\n:::\n\n```{.r .cell-code}\nmelt(iris.wide, measure.vars=measure(value.name, dim, pattern=\"(.*)[.](.*)\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Species    dim Sepal Petal\n    <fctr> <char> <num> <num>\n1:  setosa Length   5.1   1.4\n2:  setosa  Width   3.5   0.2\n```\n\n\n:::\n:::\n\n\nThe result above has reshaped the four numeric input columns into two numeric output columns (`value.name` is the sentinel/keyword indicating that we want to make a new column for each unique value captured in that group). The equivalent `nc` code would be as below, with the regex defined using a named argument for each capture group (instead of one long `pattern` string with parentheses for each capture group).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc::capture_melt_multiple(\n  iris.wide,\n  column=\".*\",\n  \"[.]\",\n  dim=\".*\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Species    dim Petal Sepal\n    <fctr> <char> <num> <num>\n1:  setosa Length   1.4   5.1\n2:  setosa  Width   0.2   3.5\n```\n\n\n:::\n:::\n\n\nThe `nc` code above produces the same result, and in fact uses `data.table::melt()` internally.\n\nFor more info about the `nc` package, please read the vignettes on [its CRAN page](https://cran.r-project.org/package=nc).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}