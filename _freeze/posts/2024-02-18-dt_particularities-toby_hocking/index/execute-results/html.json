{
  "hash": "798c6fb97af49d9286275cff53095950",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Column assignment and reference semantics in data.table\"\nauthor: \"Toby Hocking\"\ndate: \"2024-02-18\"\ncategories: [tips, tutorials, developer]\ndraft: false\nimage: \"copy_on_modify.png\"\n---\n\n\n\n\nThe goal of this blog post is to explain some similarities and differences between the base R `data.frame` object type, and the `data.table` object type. We will focus on accessing and assigning values, and discuss two major differences:\n\n-   **Syntax** means the structure of the code that is used: the characters and symbols that execute tasks. The `data.table` package uses a syntax where most operations can be done within the square brackets: `DT[i, j, by]`.\n\n-   **Semantics** refers to the internal structure of an object or variable. We say that a `data.table` object has *reference semantics*, meaning we can modify a `data.table` from within a function, and see those modifications after the function is done executing. In other words, two different R variables can point to, and modify, the same `data.table`.\n\n## Difference in syntax\n\nTo break down the similarities and differences in syntax, consider the data below,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"See source code\"}\nlibrary(data.table)\nlibrary(knitr)\n\nsyntax <- function(type, name, columns, code){\n  mcall <- match.call()\n  dt.args <- lapply(as.list(mcall[-1]), paste)\n  do.call(data.table, dt.args)\n}\n\nsyntax.tab <- rbind(\n  syntax(frame, literal, one, \"df$col_name <- value\"),\n  syntax(table, literal, one, \"DT[, col_name := value]\"),\n  syntax(frame, variable, multiple, 'df[, col_names_list] <- values'),\n  syntax(table, variable, multiple, 'DT[, (col_names_list) := values]'))\n\nsyntax.tab |> kable()\n```\n\n::: {.cell-output-display}\n\n\n|type  |name     |columns  |code                             |\n|:-----|:--------|:--------|:--------------------------------|\n|frame |literal  |one      |df$col_name <- value             |\n|table |literal  |one      |DT[, col_name := value]          |\n|frame |variable |multiple |df[, col_names_list] <- values   |\n|table |variable |multiple |DT[, (col_names_list) := values] |\n\n\n:::\n:::\n\n\n\n\nThe table above defines the different syntax required to do column assignment in data tables (`DT`) and frames (`df`).\n\n-   `type` indicates object type: *frame* or *table*.\n\n-   `name` indicates whether the column(s) to assign are literally written in the code (`col_name`), or if the names are stored in a variable (`col_names_list`).\n\n-   `columns` indicates whether only one or multiple (one or more) columns can be assigned using the syntax.\n\n-   `code` is the exact syntax of the R code used for the assignment.\n\nNote that there are other ways to do column assignment. For example,\n\n-   `DF[[\"col_name\"]] <- value` can also be used for single column assignment in a data frame.\n\n-   `set(DT, j=col_name_list, value=values)` is a more efficient version of column assignment for data tables, that is recommended for use in loops, as it avoids the overhead of the `[.data.table` method.\n\nBelow is a reshaped version of the table above, to facilitate easier comparison between `frame` and `table` versions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"See source code\"}\noptions(width=100)\ndata.table::dcast(syntax.tab, name + columns ~ type, value.var=\"code\")  |> kable()\n```\n\n::: {.cell-output-display}\n\n\n|name     |columns  |frame                          |table                            |\n|:--------|:--------|:------------------------------|:--------------------------------|\n|literal  |one      |df$col_name <- value           |DT[, col_name := value]          |\n|variable |multiple |df[, col_names_list] <- values |DT[, (col_names_list) := values] |\n\n\n:::\n:::\n\n\n\n\nThe table above shows the equivalent code for assignment of columns using either a `data.frame` or `data.table`. In fact, the code in the *frame* column above can also be used for assignment of a `data.table`, but it may be less efficient than the data table square brackets, as we will discuss in the next section.\n\nOne reason why `data.table` uses a custom assignment syntax is for consistency: the same syntax can be used, with square brackets and `:=`, for one or multiple column assignment. (Note the use parentheses around `col_names_list` in the second row of the *table* column above, to indicate that the left side of `:=` is a variable storing column names or numbers, instead of a direct unquoted column name.)\n\nAnother reason why `data.table` uses a custom assignment syntax is for efficiency, as we see in the next section.\n\n## Base \"copy on write\" versus `data.table` reference semantics\n\nR has \"copy on write\" semantics, meaning that in base R if a variable is modified inside a function, a copy is made of the whole variable. For example, consider the code below\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_outside <- data.table(x=1:3)\n\nbase_assign <- function(dt_inside, variable, value){\n  dt_inside[1,variable] <- value # makes a copy of input variable!\n}\n\nbase_assign(dt_outside, \"x\", 0)\n\ndt_outside\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       x\n   <int>\n1:     1\n2:     2\n3:     3\n```\n\n\n:::\n:::\n\n\n\n\nIn the code above, we pass `dt_outside` to the `base_assign` function, which makes a copy called `dt_inside` before it is modified, so that the data in `dt_outside` is unchanged after the function is done. Compare with the code below,\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_assign <- function(dt_inside, variable, value){\n  dt_inside[1, (variable) := value] # directly modifies input variable\n}\n\ndt_assign(dt_outside, \"x\", 0)\n\ndt_outside\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       x\n   <int>\n1:     0\n2:     2\n3:     3\n```\n\n\n:::\n:::\n\n\n\n\nThe output above shows that by using the square brackets and `:=` assignment, we can modify `data.table` objects in functions without copying them. Here, the variables `dt_inside` and `dt_outside` point to the same underlying data.\n\n### Efficiency of reference semantics\n\nReference semantics mean that `data.table` assignment is potentially much more efficient than base R, in terms of time and memory usage. To demonstrate, we use the following benchmark. Assume we have a table with $N$ rows, but we just want to modify one row. This should be a constant time/space operation (independent of $N$), but because of the base R copy on write semantics, it will be a linear time/space operation, $O(N)$.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"See source code\"}\natime_result <- atime::atime(\n  N = 10^seq(1, 7, by = 0.5),\n  setup = {\n    dt <- data.table(x = 1:N)\n  },\n  dt_assign = dt_assign(dt, \"x\", 0),\n  base_assign = base_assign(dt, \"x\", 0))\n\nplot(atime_result)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\nWe can see from the plot above that for `base_assign`, both time and space increase with $N$, because the entire table is copied; whereas `dt_assign` is constant time/space, because only one row is modified with no copy necessary.\n\n::: callout-note\nThe code in this section used a `data.table` object in both function calls to illustrate the constant time/space assignment which is possible, but the visualized result also applies to other data structures.\n\nAs an exercise, add two more expressions to the `atime` benchmark: `base_assign` with a `data.frame` object and `tibble` object. You should see linear time/space for both.\n:::\n\n## Conclusions\n\nIn this post we have explored the syntax and semantics for assignment using base R and `data.table` square brackets with `:=`, and we have seen how the reference semantics of `data.table` can be very beneficial for computational efficiency.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}