{
  "hash": "e976514f104e50fb92886ed728b7514c",
  "result": {
    "markdown": "---\ntitle: \"Particular syntax and semantics of {data.table}\"\nauthor: \"Toby Hocking\"\ndate: \"2023-12-19\"\ncategories: [tutorials]\ndraft: true\n---\n\n\nThe goal of this blog post is to explain some similarities and differences between base R data frames, and data tables. We will focus on accessing/assigning values, and discuss two major differences:\n\n-   Syntax means the structure of the code that is used. `data.table` uses a syntax where most operations can be done within the square brackets: `DT[i,j,by]`.\n-   Semantics means how the data structure/variable works. We say that a `data.table` has reference semantics, meaning we can modify a `data.table` from within a function, and see those modifications after the function is done executing. In other words, two different R variables can point to, and modify, the same `data.table`.\n\n## Difference in syntax\n\nTo discuss the similarities and differences in syntax, consider the data below,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\nsyntax <- function(type, name, columns, code){\n  mcall <- match.call()\n  dt.args <- lapply(as.list(mcall[-1]), paste)\n  do.call(data.table, dt.args)\n}\n(syntax.tab <- rbind(\n  syntax(frame, literal, one, \"DF$col <- value\"),\n  syntax(table, literal, one, \"DT[, col := value]\"),\n  syntax(frame, variable, multiple, 'DF[,cols] <- values'),\n  syntax(table, variable, multiple, 'DT[,(cols) := values]')))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     type     name  columns                  code\n   <char>   <char>   <char>                <char>\n1:  frame  literal      one       DF$col <- value\n2:  table  literal      one    DT[, col := value]\n3:  frame variable multiple   DF[,cols] <- values\n4:  table variable multiple DT[,(cols) := values]\n```\n:::\n:::\n\n\nThe table above defines the different syntax required to do column assignment in data tables and frames.\n\n-   `type` indicates data type: frame or table.\n-   `name` indicates whether the column name to assign is literally written in the code, or if a variable is specified (and the column name is taken from the value of that variable).\n-   `columns` indicates whether only one or multiple (one or more) columns can be assigned using the syntax.\n-   `code` is the syntax of the R code used for the assignment. Note that `col` is a literal column name, whereas `cols` is a variable (vector of column names or numbers).\n-   Note that there are other ways to do column assignment. For example, `DF[[\"col\"]]<-value` can also be used for single column assignment in a data frame. And `set(DT,j=cols,value=values)` is a more efficient version of column assignment for data tables (no overhead of `[.data.table` method), that is recommended for use in loops.\n\nBelow we reshape those data to facilitate comparison between frame and table versions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(width=100)\ndata.table::dcast(syntax.tab, name + columns ~ type, value.var=\"code\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: <name, columns>\n       name  columns               frame                 table\n     <char>   <char>              <char>                <char>\n1:  literal      one     DF$col <- value    DT[, col := value]\n2: variable multiple DF[,cols] <- values DT[,(cols) := values]\n```\n:::\n:::\n\n\nThe table above shows the equivalent code for assignment of columns using either a data frame or table. In fact, the code in the `frame` column above can also be used for assignment of a data table (but may be less efficient than the data table square brackets, see dicussion in next section).\n\n-   One reason why `data.table` uses a custom assignment syntax is for consistency (same syntax using square brackets and `:=` for one or multiple column assignment). Note the parentheses in the second row of the `table` column above: if the left side of `:=` is an expression, it should evaluate to a value that will be used to determine the columns to assign (either name or number).\n-   Another reason why `data.table` uses a custom assignment syntax is for efficiency, as we see in the next section.\n\n## Base copy on write versus `data.table` reference semantics\n\nR has \"copy on write\" semantics, meaning that base R assignment functions make a copy of the whole variable, if that variable is modified in a function. For example, consider the code below\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt.outside <- data.table(x=1:3)\nbase_assign <- function(dt.inside, variable, value){\n  dt.inside[1,variable] <- value #makes a copy!\n}\nbase_assign(dt.outside, \"x\", 0)\ndt.outside\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       x\n   <int>\n1:     1\n2:     2\n3:     3\n```\n:::\n:::\n\n\nIn the code above, we pass `dt.outside` to the `base_assign` function, which makes a copy of `dt.inside` before it is modified (so then the data in `dt.outside` is unchanged after the function is done). Compare with the code below,\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_assign <- function(dt.inside, variable, value){\n  dt.inside[1, (variable) := value]\n}\ndt_assign(dt.outside, \"x\", 0)\ndt.outside\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       x\n   <int>\n1:     0\n2:     2\n3:     3\n```\n:::\n:::\n\n\nThe output above shows that by using the square brackets and `:=` assignment, we can modify without copying the data table (`dt.inside` and `dt.outside` point to the same underlying data).\n\n## Efficiency of reference semantics\n\nReference semantics mean that `data.table` assignment is potentially much more efficient than base R, in terms of time and memory usage. To demonstrate, we use the following benchmark. Assume we have a table with N rows, but we just want to modify one row. This should be a constant time/space operation (independent of N), but because of the base R copy on write semantics, it will be a linear time/space operation, O(N).\n\n\n::: {.cell}\n\n```{.r .cell-code}\natime.result <- atime::atime(\n  N=10^seq(1, 7, by=0.5),\n  setup={\n    dt <- data.table(x=1:N)\n  },\n  dt_assign=dt_assign(dt, \"x\", 0),\n  base_assign=base_assign(dt, \"x\", 0))\nplot(atime.result)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required namespace: ggplot2\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required namespace: directlabels\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nWe can see from the plot above that for `base_assign`, both time and space increase with N (because the entire table is copied), whereas `dt_assign` is constant time/space (because only one row is modified, no copy necessary).\n\nNote/exercise for the reader: the code in this section used a data table (to illustrate the constant time/space assignment which is possible), but the linear time/space also applies to other data structures. Exercise: add two more expressions to the atime benchmark: `base_assign` with `data.frame` and `tibble`. You should see linear time/space for both.\n\n## Conclusions\n\nIn this post we have explored the syntax and semantics for assignment using base R and `data.table` square brackets with `:=`, and we have seen how the reference semantics of `data.table` can be very beneficial for computational efficiency.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}