{
  "hash": "ebcd3c7c17917b63fc13489517f0a9cc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The Benefits of `data.table` Syntax\"\nauthor: \"Tyson Barrett\"\ndate: \"2024-02-05\"\ncategories: [tips, tutorials, documentation]\nimage: \"brackets.png\"\ndraft: false\n---\n\n\nAmong the many reasons to use `data.table` in your code (which includes the more common answers of speed, memory efficiency, etc.) is the **syntax**. The syntax is\n\n1.  concise,\n2.  predictable, and\n3.  R-centric.\n\nIn this post, I'd like to show how these features are beneficial and useful in working with data regardless of the size of the data. To do this, I'll use two packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\nlibrary(palmerpenguins)\n```\n:::\n\n\nand we'll create a data.table of the penguins data set (and a data.frame version for other examples):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- as.data.table(penguins)\ndf <- as.data.frame(penguins)\n```\n:::\n\n\nThis post assumes some familiarity with `data.table` syntax but even if you are new to it, there is likely a lot of information that is quite useful for you.\n\n## Concise\n\nThe syntax ultimately is built around the concise `dt[i, j, by]` framework (built on the core functionality of data frames, see the *R-centric* section below). This syntax allows you to:\n\n1.  Subset (\"filter\") your data using the `i` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset to only Adelie species\ndt[species == \"Adelie\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     species    island bill_length_mm bill_depth_mm flipper_length_mm\n      <fctr>    <fctr>          <num>         <num>             <int>\n  1:  Adelie Torgersen           39.1          18.7               181\n  2:  Adelie Torgersen           39.5          17.4               186\n  3:  Adelie Torgersen           40.3          18.0               195\n  4:  Adelie Torgersen             NA            NA                NA\n  5:  Adelie Torgersen           36.7          19.3               193\n ---                                                                 \n148:  Adelie     Dream           36.6          18.4               184\n149:  Adelie     Dream           36.0          17.8               195\n150:  Adelie     Dream           37.8          18.1               193\n151:  Adelie     Dream           36.0          17.1               187\n152:  Adelie     Dream           41.5          18.5               201\n     body_mass_g    sex  year\n           <int> <fctr> <int>\n  1:        3750   male  2007\n  2:        3800 female  2007\n  3:        3250 female  2007\n  4:          NA   <NA>  2007\n  5:        3450 female  2007\n ---                         \n148:        3475 female  2009\n149:        3450 female  2009\n150:        3750   male  2009\n151:        3700 female  2009\n152:        4000   male  2009\n```\n\n\n:::\n:::\n\n\nOther ways to do this include the more redundant base R approach\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[df$species == \"Adele\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata frame with 0 columns and 344 rows\n```\n\n\n:::\n:::\n\n\nand the more verbose approach in the tidyverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ndf %>% \n  filter(species == \"Adele\")\n```\n:::\n\n\n2.  Mutate or transform your variables using the `j` argument. Note that the use of `:=` mutates in place so no need for other assignment (e.g., `<-`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# change body_mass_g to pounds\ndt[, body_mass_lbs := body_mass_g*0.00220462]\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n       species body_mass_lbs\n        <fctr>         <num>\n  1:    Adelie      8.267325\n  2:    Adelie      8.377556\n  3:    Adelie      7.165015\n  4:    Adelie            NA\n  5:    Adelie      7.605939\n ---                        \n340: Chinstrap      8.818480\n341: Chinstrap      7.495708\n342: Chinstrap      8.322441\n343: Chinstrap      9.038942\n344: Chinstrap      8.322441\n```\n\n\n:::\n:::\n\n\nWe could also do this in base R a number of ways, all of which are more redundant:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$body_mass_lbs <- df$body_mass_g*0.00220462\ndf[, \"body_mass_lbs\"] <- df[, \"body_mass_g\"]*0.00220462\ndf[[\"body_mass_lbs\"]] <- df[[\"body_mass_g\"]]*0.00220462\n```\n:::\n\n\n3.  Do all sorts of data work on groups using the `by` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a new variable that is the average of the body mass by species\ndt[, avg_mass_lbs := mean(body_mass_lbs, na.rm=TRUE), by = sex]\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n       species    sex avg_mass_lbs\n        <fctr> <fctr>        <num>\n  1:    Adelie   male    10.021507\n  2:    Adelie female     8.514844\n  3:    Adelie female     8.514844\n  4:    Adelie   <NA>     8.830728\n  5:    Adelie female     8.514844\n ---                              \n340: Chinstrap   male    10.021507\n341: Chinstrap female     8.514844\n342: Chinstrap   male    10.021507\n343: Chinstrap   male    10.021507\n344: Chinstrap female     8.514844\n```\n\n\n:::\n:::\n\n\nThis is more difficult, but possible, in base R to get a summary and add it to the existing data.frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntapply(df$body_mass_lbs, df$sex, mean, na.rm=TRUE) # doesn't keep all rows\n\n# does keep all rows but complicated code\ndf <- \n  by(df, INDICES = df$sex,                           \n     FUN = function(x){\n       x$avg_mass_lbs <- mean(x$body_mass_lbs)\n       return(x)\n  })\ndf <- do.call(\"rbind\", df)\n```\n:::\n\n\nand can definitely be done in the tidyverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df %>% \n  group_by(sex) %>% \n  mutate(avg_mass_lbs = mean(body_mass_lbs, na.rm=TRUE)) %>% \n  ungroup()\n```\n:::\n\n\nIn each example, you can see a lot of work can be done in a single line of code with minimal redundancy. Although in each situation base R and tidyverse equivalents exist (often with a lot of powerful flexibility in the tidyverse approaches), the concise nature of `data.table` syntax can make writing and reading the code quicker.\n\n## Predictable\n\nThe syntax is naturally predictable without being verbose. For instance, whenever you use `:=`, it's going to keep the same shape as the current data (\"mutate\") while the use of `.(var = fun(x))` will summarize to the fewest number of rows appropriate (1 row for non-grouped expressions and x rows for x number of unique groups).\n\nTo get an idea of how this predictability manifests in the code, we'll use an example. Here, we can grab the average bill length by sex. We could do this two ways. The first is mutating in place where the data do not change size or shape. *Note, the `.()` function is shorthand for `list()`.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, avg_bill_length := mean(bill_length_mm, na.rm=TRUE), by = sex]\n```\n:::\n\n\nThis gives us a new variable in the original data.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n       species    sex avg_bill_length\n        <fctr> <fctr>           <num>\n  1:    Adelie   male        45.85476\n  2:    Adelie female        42.09697\n  3:    Adelie female        42.09697\n  4:    Adelie   <NA>        41.30000\n  5:    Adelie female        42.09697\n ---                                 \n340: Chinstrap   male        45.85476\n341: Chinstrap female        42.09697\n342: Chinstrap   male        45.85476\n343: Chinstrap   male        45.85476\n344: Chinstrap female        42.09697\n```\n\n\n:::\n:::\n\n\nHowever, sometimes we just want the data summarized. We can use the syntax below for that (notice no `:=`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[, .(avg_bill_length = mean(bill_length_mm, na.rm=TRUE)), by = sex]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      sex avg_bill_length\n   <fctr>           <num>\n1:   male        45.85476\n2: female        42.09697\n3:   <NA>        41.30000\n```\n\n\n:::\n:::\n\n\nWe can always assign this so we can access it later.\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_bill <- dt[, .(avg_bill_length = mean(bill_length_mm, na.rm=TRUE)), by = sex]\n```\n:::\n\n\nOne way `data.table` makes the code predictable is that the data operations happen all within the square brackets without lingering attributes that may produce surprising results. That is, whatever I put in the brackets will be run together and then done. For example, I may have several grouping variables that I use to modify some variables, and only do it for a subset of the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[species == \"Adelie\", max_bill := max(bill_length_mm, na.rm=TRUE), by = .(species, sex)]\n```\n:::\n\n\nThe new variable `max_bill` is made for the data but is only applicable to the Adelie species and is done by both species as sex. Once this operation is done, the grouping variables are just normal variables again and we still have access to the full data.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n       species    sex max_bill\n        <fctr> <fctr>    <num>\n  1:    Adelie   male     46.0\n  2:    Adelie female     42.2\n  3:    Adelie female     42.2\n  4:    Adelie   <NA>     42.0\n  5:    Adelie female     42.2\n ---                          \n340: Chinstrap   male       NA\n341: Chinstrap female       NA\n342: Chinstrap   male       NA\n343: Chinstrap   male       NA\n344: Chinstrap female       NA\n```\n\n\n:::\n:::\n\n\n## R-centric\n\nAll of the main functionality in `data.table` is structured around vectors, lists, and (a modified form) of data frames. These core structures in `R` can be seeing throughout the syntax and design of the package. Even the `dt[i, j, by]` syntax is designed to mirror (and simplify) data frames. For new users, this can be particularly useful: no additional data structures are needed to work with the data and do both simple and complicated data operations.\n\n# Conclusions\n\nIn my experience, as one gets more familiar with the syntax of `data.table`, the more it becomes clear that the syntax (although less verbose than other approaches like the tidyverse), is concise, predictable, and familiar to the basics of the R programming language. Among many reasons to leverage `data.table` in your workflow, the syntax is one to not overlook.\n\nCover photo by <a href=\"https://unsplash.com/@christinhumephoto?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Christin Hume</a> on <a href=\"https://unsplash.com/photos/person-using-laptop-computer-Hcfwew744z4?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Unsplash</a>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}