---
title: "Particular syntax and semantics of {data.table}"
author: "Toby Hocking"
date: "2023-12-19"
categories: [tutorials]
draft: true
---

The goal of this blog post is to explain some similarities and differences between base R data frames, and data tables. We will focus on accessing/assigning values, and discuss two major differences:

-   Syntax means the structure of the code that is used. `data.table` uses a syntax where most operations can be done within the square brackets: `DT[i,j,by]`.
-   Semantics means how the data structure/variable works. We say that a `data.table` has reference semantics, meaning we can modify a `data.table` from within a function, and see those modifications after the function is done executing. In other words, two different R variables can point to, and modify, the same `data.table`.

## Difference in syntax

To discuss the similarities and differences in syntax, consider the data below,

```{r}
library(data.table)
syntax <- function(type, name, columns, code){
  mcall <- match.call()
  dt.args <- lapply(as.list(mcall[-1]), paste)
  do.call(data.table, dt.args)
}
(syntax.tab <- rbind(
  syntax(frame, literal, one, "DF$col <- value"),
  syntax(table, literal, one, "DT[, col := value]"),
  syntax(frame, variable, multiple, 'DF[,cols] <- values'),
  syntax(table, variable, multiple, 'DT[,(cols) := values]')))
```

The table above defines the different syntax required to do column assignment in data tables and frames.

-   `type` indicates data type: frame or table.
-   `name` indicates whether the column name to assign is literally written in the code, or if a variable is specified (and the column name is taken from the value of that variable).
-   `columns` indicates whether only one or multiple (one or more) columns can be assigned using the syntax.
-   `code` is the syntax of the R code used for the assignment. Note that `col` is a literal column name, whereas `cols` is a variable (vector of column names or numbers).
-   Note that there are other ways to do column assignment. For example, `DF[["col"]]<-value` can also be used for single column assignment in a data frame. And `set(DT,j=cols,value=values)` is a more efficient version of column assignment for data tables (no overhead of `[.data.table` method), that is recommended for use in loops.

Below we reshape those data to facilitate comparison between frame and table versions:

```{r}
options(width=100)
data.table::dcast(syntax.tab, name + columns ~ type, value.var="code")  
```

The table above shows the equivalent code for assignment of columns using either a data frame or table. In fact, the code in the `frame` column above can also be used for assignment of a data table (but may be less efficient than the data table square brackets, see dicussion in next section).

-   One reason why `data.table` uses a custom assignment syntax is for consistency (same syntax using square brackets and `:=` for one or multiple column assignment). Note the parentheses in the second row of the `table` column above: if the left side of `:=` is an expression, it should evaluate to a value that will be used to determine the columns to assign (either name or number).
-   Another reason why `data.table` uses a custom assignment syntax is for efficiency, as we see in the next section.

## Base copy on write versus `data.table` reference semantics

R has "copy on write" semantics, meaning that base R assignment functions make a copy of the whole variable, if that variable is modified in a function. For example, consider the code below

```{r}
dt.outside <- data.table(x=1:3)
base_assign <- function(dt.inside, variable, value){
  dt.inside[1,variable] <- value #makes a copy!
}
base_assign(dt.outside, "x", 0)
dt.outside
```

In the code above, we pass `dt.outside` to the `base_assign` function, which makes a copy of `dt.inside` before it is modified (so then the data in `dt.outside` is unchanged after the function is done). Compare with the code below,

```{r}
dt_assign <- function(dt.inside, variable, value){
  dt.inside[1, (variable) := value]
}
dt_assign(dt.outside, "x", 0)
dt.outside
```

The output above shows that by using the square brackets and `:=` assignment, we can modify without copying the data table (`dt.inside` and `dt.outside` point to the same underlying data).

## Efficiency of reference semantics

Reference semantics mean that `data.table` assignment is potentially much more efficient than base R, in terms of time and memory usage. To demonstrate, we use the following benchmark. Assume we have a table with N rows, but we just want to modify one row. This should be a constant time/space operation (independent of N), but because of the base R copy on write semantics, it will be a linear time/space operation, O(N).

```{r}
atime.result <- atime::atime(
  N=10^seq(1, 7, by=0.5),
  setup={
    dt <- data.table(x=1:N)
  },
  dt_assign=dt_assign(dt, "x", 0),
  base_assign=base_assign(dt, "x", 0))
plot(atime.result)
```

We can see from the plot above that for `base_assign`, both time and space increase with N (because the entire table is copied), whereas `dt_assign` is constant time/space (because only one row is modified, no copy necessary).

Note/exercise for the reader: the code in this section used a data table (to illustrate the constant time/space assignment which is possible), but the linear time/space also applies to other data structures. Exercise: add two more expressions to the atime benchmark: `base_assign` with `data.frame` and `tibble`. You should see linear time/space for both.

## Conclusions

In this post we have explored the syntax and semantics for assignment using base R and `data.table` square brackets with `:=`, and we have seen how the reference semantics of `data.table` can be very beneficial for computational efficiency.
