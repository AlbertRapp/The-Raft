---
title: "Use of non-API functions in `data.table`"
author: "Ivan Krylov"
date: "2024-12-12"
categories: [code]
# image: "image.jpg"
draft: true
bibliography: refs.bib
---

```{r}
#| echo: false
library(data.table)
library(tools) # format.check_details
load('precomputed.rda')
```

In the late 1970's, people at Bell Laboratories designed the S
programming language in order to facilitate interactive exploratory data
analysis [@Chambers2016]. Instead of writing, compiling, scheduling, and
interpreting the output of individual Fortran programs, the goal of S
was to conduct all the necessary steps of the analysis on the fly. S
achieved this not by replacing the extensive collection of Fortran
subroutines, but by providing a special interface language [@Becker1985]
through which S could communicate with compiled code.

Fast forward more than four decades and an increase by more than three
orders of magnitude in storage and processing capability of computers
around us. The [dominant implementation of S is now R][is.R]. It is now
feasible to implement algorithms solely in R, recouping the potential
performance losses in performance by reducing the programmer effort
spent debugging and maintaining the code [@Nash2024]. Still, the
capability of R to be extended by special-purpose compiled code is as
important as ever. As of `r when`,
`r round(sum(needscomp)/length(needscomp)*100)`% of CRAN packages use
compiled code. Since the implementation language of R is C, not Fortran,
the programming interface for R is also defined in terms of C.

What's in an API?
=================

[Writing R Extensions][WRE] ("WRE") is the definitive guide for R
package development. Together with the [CRAN policy][CRANpolicy] it
forms the "rules as written" that the maintainers of CRAN packages must
follow. A recent version of R exports `r nrow(symbols)` symbols,
including `r symbols[,sum(type=='function')]` functions ("entry points",
not counting C preprocessor macros) and
`r symbols[,sum(type!='function')]` variables. Not all of them are
intended to be used by packages. Even back in R-3.3.0, the oldest
version currently supported by `data.table`, [WRE chapter 6, "The R
API"][WRE33API] classified R's entry points into four categories:

> * __API__
>   Entry points which are documented in this manual and declared in an
>   installed header file. These can be used in distributed packages and
>   will only be changed after deprecation.
> * __public__
>   Entry points declared in an installed header file that are exported
>   on all R platforms but are not documented and subject to change
>   without notice.
> * __private__
>   Entry points that are used when building R and exported on all R
>   platforms but are not declared in the installed header files. Do not
>   use these in distributed code.
> * __hidden__
>   Entry points that are where possible (Windows and some modern
>   Unix-alike compilers/loaders when using R as a shared library) not
>   exported.

Although nobody objected to the use of the _API_ entry points, and there
was little point in trying to use the _hidden_ entry points in a package
that would fail to link almost everywhere, the _public_ and the
_private_ entry points ended up being a point of contention. Those
deemed too internal to use but not feasible to make _hidden_ were (and
still are) listed in the character vector `tools:::nonAPI`: ` R CMD
check ` looks at the functions imported by the package and signals a
`NOTE` if it finds any listed there.

The remaining _public_ functions, neither documented as API nor
explicitly forbidden by ` R CMD check `, sat there, alluring the package
developers with their offers. For example, the [serialization
interface][ltierney_serialize] is only [documented in WRE since
R-4.5][WRE45serialize], but it has been powering part of the [digest]
CRAN package since 2019 (and other packages before it) without any
drastic changes. Some of the inclusions in `tools:::nonAPI` could have
been historical mistakes: while WRE has been saying [back in version
3.3.0][WRE33wilcox] that `wilcox_free` should be called after a call to
the (API) functions `dwilcox`, `pwilcox` or `qwilcox`, the function was
only [declared in the public headers][wilcox_declared] and [removed from
`tools:::nonAPI`][wilcox_api] in R-4.2.0. Still, between R-3.3.3 and
R-4.4.2, `tools:::nonAPI` grew from `r length(nonAPI.3_3)` to
`r length(nonAPI.4_4)` entries, and the package maintainers had to adapt
or face archival of their packages.

A [recent question on R-devel][ALTREPnonAPI] (whether the [ALTREP]
interface should be considered "API" for the purpose of CRAN package
developent) sparked a series of events and an extensive discussion
containing the highest count of occurrences of the word "API" per month
ever seen on R-devel (234), topping [October 2002][Rd200210] (package
versioning and API breakage, 150), [October 2005][Rd200510] (API for
graphical interfaces and console output, 124), and [May 2019][Rd201905]
(discussions of the ALTREP interface and multi-threading, 121). As a
result, Luke Tierney [started work][clarifyingAPI] on programmatically
describing the functions and other symbols exported by R (including
variables and preprocessor and enumeriation constants), giving a
stronger definition to the interface. His changes add the currently
unexported function `tools:::funAPI()` that lists entry points and two
more of their categories:

> * __experimental__
>   Entry points declared in an installed header file that are part of
>   an experimental API, such as `R_ext/Altrep.h`. These are subject to
>   change, so package authors wishing to use these should be prepared
>   to adapt.
> * __embedding__
>   Entry points intended primarily for embedding and creating new
>   front-ends. It is not clear that this needs to be a separate
>   category but it may be useful to keep it separate for now.

Additionally, WRE now spells out that entry points not explicitly
documented or at least listed in the output of `tools:::funAPI` (or
something that will replace it) are now off-limits, even if not
currently present in `tools:::nonAPI` (emphasis added):

> * __public__
>   Entry points declared in an installed header file that are exported
>   on all R platforms but are not documented and subject to change
>   without notice. _Do not use these in distributed code. Their
>   declarations will eventually be moved out of installed header
>   files._

Correspondingly, the number of `tools:::nonAPI` entry points in the
current development version of R rose to `r length(nonAPI.trunk)`, hence
the present blog post.

<!-- MAYBE: mention Rf_ remapping and typical APIs look like at some
point -->

<!-- MAYBE: how did Rinternals change since 3.3.0? USE_RINTERNALS is
gone -->

<!-- MAYBE: somehow obtain the list of imports (mirror Windows builds
from CRAN? download the one compiled by Luke Tierney?) and try to
extract neither-official-API nor-official-nonAPI counts -->

<!-- MAYBE: see which listed non-API functions are the most "popular" in
packages still on CRAN -->

Use of non-API entry points in `data.table`
===========================================

The first version of the `data.table` package in the CRAN archive dates
back to April 2006 (which corresponds to R version 2.3.0). It has been
evolving together with R and its API and thus has accumulated a number
of uses of R internals that are [no longer considered part of the
API][remove_non_API]:

`r gsub(
 '(?m)^', '>     ', perl = TRUE,
 format(subset(dtchecks, grepl('API', Output))[1,])
)`

 -- ` R CMD check --as-cran ` on a released version of `data.table`

Testing for a `data.frame`: `isFrame`
-------------------------------------

Back in 2012, Matt Dowle needed to quickly test an object for being a
`data.frame`, and the undocumented function `isFrame` seemed like it
[did the job][datatable_isframe_added]. Since `isFrame` was not part of
the documented API, in 2024 Luke Tierney gave the function a
better-fitting name, [`isDataFrame`][R_isdataframe_added], and made it
an experimental API, while retaining the original function as a wrapper.

Use of `isFrame` [doesn't give a `NOTE` yet][remove_isframe], but when
R-4.5.0 is released together with the new name for the function,
`data.table` will be able to use it, falling back to `isFrame` on older
versions of R. `isDataFrame` is documented among other [replacement
entry point names][WRE_replacement_entrypoints] in Writing R Extensions.

Problem (the only instance in `data.table`):

```c
if (!isVector(thiscol) || isFrame(thiscol))
                       /* ^^^^^^^ may disappear in a future R version */
```

Solution:

```c
// include non-R headers first

// include R headers last
#include <R.h>
#include <Rinternals.h>

// provide overrides after the R headers
#if R_VERSION < R_Version(4, 5, 0)
// R versions older than 4.5.0 released use the old name of the function
#define isDataFrame(x) isFrame(x)
#endif

// later:
if (!isVector(thiscol) || isDataFrame(thiscol))
```

Operating on the S4 bit: `IS_S4_OBJECT`, `SET_S4_OBJECT`, `UNSET_S4_OBJECT`
---------------------------------------------------------------------------

The `data.table` class is [registered][setOldClass] with the S4 OOP
system, making it possible to create S4 classes containing `data.table`s
as members (`setClass(slots = c(mytable = 'data.table'))`) or even
inheriting from `data.table` (and, in turn, from `data.frame`:
`setClass(contains = 'data.table')`). This latter case requires care
from the C code: when creating a copy of an S4 `data.table` from scratch
(or setting all attributes from one object onto another), the
destination value must also end up being an S4 object. This is
controlled by the special "S4" bit in the header of every R object, so
the code must read and set it correctly. <!-- MAYBE: say and link where
exacly data.table does this -->

The undocumented functions `IS_S4_OBJECT`, `SET_S4_OBJECT`,
`UNSET_S4_OBJECT` exist as bare interfaces to [the internal
macros][IS_S4_OBJECT] of the same names and directly access the flag
inside their argument.

The [`Rf_isS4`][isS4] function is a wrapper for `IS_S4_OBJECT` that
follows the usual naming convention for remapped functions, has been
part of the API for a long time, and could implement additional checks
if they are needed by R. The [`Rf_asS4`][asS4] function (experimental
API) is more involved, making sure to operate on a shallow copy of an
object instead of overwriting it in place and trying to "deconstruct" S4
objects into S3 objects if possible and requested.

Solution: [use `Rf_isS4` instead of
`IS_S4_OBJECT`][remove_set_s4_object], as
[documented][WRE_replacement_entrypoints] in Writing R Extensions. Use
`Rf_asS4` to control the S4 object bit, but be careful <!--how?-->
around shared objects.

<!-- TODO: expand on this, make sure the asS4 advice is correct -->

Converting between calls and pairlists: `SET_TYPEOF`
----------------------------------------------------

In R, [function calls][call] are internally represented as Lisp-style
pairlists where the first pair is of special type `LANGSXP` instead of
`LISTSXP`. For example, the following diagram illustrates the data
structure of the call `print(x = 42L)`:

![](langsxp.svg){width=40em}

Here, every list item is a separate R object, a "cons cell"; each cell
contains the value in its `CAR` field and a reference to the rest of the
list in its `CDR` field. Argument names, if provided, are stored in the
third field, `TAG`.  The list is terminated by `R_NilValue`, which is of
type `NILSXP`. These structures must be constructed every time C code
wants to evaluate a function call. <!-- MAYBE: say and link where
exacly data.table does this -->

Previously, R API contained a function to allocate `LISTSXP` pairlists
of arbitrary length, `allocList()`, but not function calls, so it became
a somewhat common idiom to first allocate the list and then use
`SET_TYPEOF` to change the type of the head pair to `LANGSXP`. This
did not previously lead to problems, since the two types have the same
internal memory layout.

The danger of `SET_TYPEOF` lies in the possibility to set the type of an
R value to one with an incompatible memory layout. (For example, vector
types `REALSXP` and `INTSXP` are built very differently from cons cells
`LISTSXP` and `LANGSXP`.) Starting with R-4.4.1, [R contains the
`allocLang` function in addition to the `allocList` function][WRE_call]
that directly allocates a function call object with a head pair of type
`LANGSXP`. In order to stay compatible with previous R versions,
packages may [allocate the `LISTSXP` tail first and then use `lcons()`
to construct the `LANGSXP` head pair of the call][remove_set_typeof].


Problem (the only instance in `data.table`):

```c
   SEXP s = PROTECT(allocList(2));
   SET_TYPEOF(s, LANGSXP);
// ^^^^^^^^^^ unsafe operation, could be used to corrupt objects
   SETCAR(s, install("format.POSIXct"));
   SETCAR(CDR(s), column);
```

Solutions:

```c
// for fixed-size calls with contents known ahead of time
SEXP s = lang2(install("format.POSIXct"), column);
```
or:
```c
// partially pre-populate
SEXP s = lang2(install("format.POSIXct"), R_NilValue);
// later, when 'column' is known:
SETCAR(CDR(s), column);
```
or:
```c
// allocate a call with 'n' elements
SEXP call = lcons(R_NilValue, allocList(n - 1));

// in R >= 4.4.1 only:
SEXP call = allocLang(n);
```

Unfortunately, the `LCONS` macro didn't work with `#define R_NO_REMAP`
prior to R-4.4, because it expanded to `lcons()` instead of
`Rf_lcons()`.

Strings as C arrays of `CHARSXP` values: `STRING_PTR`
-----------------------------------------------------

From the point of view of R code, strings are very simple things, much
like numbers: they live in atomic vectors and can be directly compared
with other objects. It is only natural to desire to work with them as
easily from C code as it's possible with other atomic types, where
functions `REAL()`, `INTEGER()`, or `COMPLEX()` can be used to access
the buffer containing the numbers.

The underlying reality of strings is more complicated: since they
internally manage memory buffers containing text in a given encoding,
they must be subject to garbage collection. Like other managed objects
in R, they are represented as `SEXP` values of special type `CHARSXP`.
R's garbage collector is [generational][Tierney_gengc] and requires the
use of [write barrier][Tierney_writebr] any time a `SEXP` value (such as
a `STRSXP` vector) references another `SEXP` value (such as a `CHARSXP`
string). In a generational garbage collector, "younger" generations are
marked and sweeped more frequently than "older" ones. If package C code
manually writes a reference to a "young" `CHARSXP` object into an "old"
`STRSXP` vector without taking generations into account, a following
collection of the "young" pool of objects will miss the `CHARSXP` being
referenced by the "old" `STRSXP` and remove the `CHARSXP` as "garbage".
This makes the `SEXP *` pointers returned by `STRING_PTR` unsafe and
requires the use of `STRING_PTR_RO` function, which returns a read-only
`const SEXP *`.

Thankfully, `data.table` has already been using read-only `const SEXP *`
pointers when working with `STRSXP` vectors, so the required changes to
the code were [not too substantial][remove_string_ptr], only changing
the name of the accessor function used:

Example of the problem:

```c
const SEXP *sourceD = STRING_PTR(source);
//                    ^^^^^^^^^^
// returns a writeable SEXP * pointer, therefore unsafe
```

Solution:

```c
// first include non-R headers

// next include R headers

// then provide version-specific overrides
#if R_VERSION < R_Version(3, 5, 0)
// STRING_PTR_RO only appeared in R-3.5
#define STRING_PTR_RO(x) STRING_PTR(x)
#endif

// later:
const SEXP *sourceD = STRING_PTR_RO(source);
//                    ^^^^^^^^^^^^^
// returns a const SEXP * pointer, which prevents accidental writes
```

See also: [PR18775].

Reading the reference counts: `NAMED`
-------------------------------------

In plain R, all value types -- numbers, strings, lists -- have
pass-by-value semantics. Wihout dark and disturbing things in play, such
as non-standard evaluation or active bindings, R code can give a plain
value (`x <- 1:10`) to a function (`f(x)`) or store it in a variable (`y
<- x`), have the function modify its argument (`f <- \(x) { x[1] <- 0
}`) or change the duplicate variable (`y[2] <- 3`), and still have the
original value intact (`stopifnot(identical(x, 1:10))`). Only the
inherently mutable types, such as environments, external pointers and
weak references, will stay shared between all assignments and function
arguments; the value types behave as if R copies them every time.

And yet actually making these copies is wasteful when the code only
reads the variable and does not alter it. (In fact, one of the original
motivations of `data.table` was to further reduce wasteful copying that
R used to perform during certain sub-assignment operations.) Until
version 4.0.0, `NAMED` was R's mechanism to save memory and CPU time
instead of creating and storing these copies. A temporary object such as
the value of `1:10` was not bound to a symbol and thus could be modified
right away. Assigning it to a variable, as in `x <- 1:10`, gave it a
`NAMED(x)` count of 1, for which R had an internal optimisation in
replacement function calls like `foo(x) <- 3`.  Assigning the same value
to yet another symbol (by copying `y <- x` or calling a function
`foo(x)`) increased the `NAMED()` count to 2 or more, for which there
was no optimisation: in order to modify one of the symbols, R was
required to duplicate `x` first. `NAMED()` was not necessarily decreased
after the bindings disappeared, and decreasing it after having reached
`NAMEDMAX` was impossible. During the lifetime of R-3.x, `NAMEDMAX` was
increased from 2 to 3 and later to 7.

Between R-3.1.0 and R-4.0.0, R [migrated from `NAMED` to reference
counting][Tierney_refcnt]. Reference counts are easier to properly
decrement than `NAMED`, thus preventing unneeded copies of objects that
became unreferenced. R-3.5.0 [documented the symbols][Rnews_setnamed]
`MAYBE_REFERENCED(.)` / `NO_REFERENCES(.)` for use instead of checking
`NAMED(.) == 0`, `MAYBE_SHARED(.)` / `NOT_SHARED(.)` instead of checking
`NAMED(.) > 1`, and `MARK_NOT_MUTABLE(.)` instead of setting `NAMED(.)`
to `NAMEDMAX`, which later became part of the API instead of the
`NAMED(.)` and `REFCNT(.)` functions. The hard rules are that a value is
safe to modify in place if it has `NO_REFERENCES()` (reference count of
0), definitely unsafe to modify in place (requiring a call to
`duplicate` or `shallow_duplicate`) if it is `MAYBE_SHARED()` (reference
count above 1), and almost certainly unsafe to modify in place if it is
`MAYBE_REFERENCED()` (reference count of 1).

`data.table`'s only uses of `NAMED()` were in the [verbose output during
assignment][remove_named]:

```c
if (verbose) {
  Rprintf(_("RHS for item %d has been duplicated because NAMED==%d MAYBE_SHARED==%d, but then is being plonked. length(values)==%d; length(cols)==%d)\n"),
          i+1, NAMED(thisvalue), MAYBE_SHARED(thisvalue), length(values), length(cols));
               ^^^^^ non-API function
}
```

Since the correctness of the modification operation hinges on the
reference count being 0 (and it may be important whether it's exactly 1
or above 1), the same amount of _useful_ information can be conveyed by
printing `MAYBE_REFERENCED()` and `MAYBE_SHARED()` instead of `NAMED()`:

```c
if (verbose) {
  Rprintf(_("RHS for item %d has been duplicated because MAYBE_REFERENCED==%d MAYBE_SHARED==%d, but then is being plonked. length(values)==%d; length(cols)==%d)\n"),
          i+1, MAYBE_REFERENCED(thisvalue), MAYBE_SHARED(thisvalue), length(values), length(cols));
               ^^^^^^^^^^^^^^^^ API function
}
```

Encoding bits: `LEVELS`
-----------------------

`LEVELS` is the name of the internal R [macro][LEVELS_macro] and an
exported non-API [function][LEVELS_function] accessing a [16-bit field
called `gp`][LEVELS_field] that is present in the header of every `SEXP`
value.  Not every access to this field is done using the `LEVELS()`
macro; there are bits of R code that access `(sexp)->sxpinfo.gp`
directly. R uses this field for many purposes:

 * matching given arguments against the formals of a function
   ([1][gp_for_match1], [2][gp_for_match2], [3][gp_for_match3])
 * remembering the previous [type][gp_for_gc] of a garbage-collected value
 * [finalizing][gp_for_finalize] the reference-semantics objects before
   garbage-collecting them
 * [marking][gp_for_calling] condition handlers as "calling" (executing
   on top of where the condition was signalled in the call stack), as
   opposed to "non-calling" (executing at the site of the `tryCatch`
   call)
 * [marking][gp_for_assignment] objects in complex assignment calls
 * storing the [S4 object bit][gp_for_s4]
 * [marking][gp_for_jit] functions as (un)suitable for bytecode
   compilation
 * [marking][gp_for_growable] vectors as growable
 * [marking][gp_for_missing] provided ("actial") function arguments as
   [missing][gp_for_missing2]
 * [marking][gp_for_ddval] the `..1`, `..2`, etc symbols as
   corresponding to the [given element of the `...`
   argument][Rhelp_dots]
 * [marking][gp_for_env] environments as [locked][envflags_locked], or
   for [caching][envflags_global] the global variable lookup, or for
   looking up values in the base environment or the special functions
   ([1][gp_for_basesym], [2][basesym2], [3][gp_for_special],
   [4][specialsym2])
 * [marking][gp_for_hashash] symbols naming environment contents for
   [hash lookup][hashash2]
 * [marking][gp_for_active] bindings inside environments as
   [active][active_binding]
 * [marking][gp_for_promsxp] promise objects as already evaluated
 * [marking][gp_for_charsxp] `CHARSXP` values as present in the global
   cache or being in a certain encoding

Although the value of `gp` is directly stored in R's serialized data
stream, neither of these are part of the API. Out of all possible uses
for this flag, `data.table` is only interested in string encodings. From
the viewpoints of [plain R][R_Encoding] and the [C API][WRE_encoding],
an individual string (`CHARSXP` value) can be marked with the following
encodings:

R-level encoding name | C-level encoding constant | Meaning
:----------------:|:----------------:|------------------------------
`"latin1"`        | `CE_LATIN1`      | ISO/IEC 8859-1 or CP1252
`"UTF-8"`         | `CE_UTF8`        | ISO/IEC 10646
`"unknown"`       | `CE_NATIVE`      | Encoding of the current locale
`"bytes"`         | `CE_BYTES`       | Not necessarily text; `translateChar` will fail

Internally, R also [marks strings as encoded in ASCII][R_SET_ASCII]:
since all three encodings are ASCII-compatible, an ASCII string will
never need to be translated into a different encoding. Note that there
is a subtle difference between a string _marked_ in a certain encoding
and actually _being_ in a certain encoding: in an R session running with
a UTF-8 locale (which includes most modern Unix-alikes and Windows &ge;
10, November 2019 update) a string marked as `CE_NATIVE` will also be in
UTF-8. (Similarly, with an increasingly rare Latin-1 locale, a
`CE_NATIVE` string will be in Latin-1.)

The `data.table` code is interested in knowing whether a string is
[marked as UTF-8, Latin-1, or ASCII][datatable_isencoded]. This is used
to [convert strings to UTF-8 when needed][datatable_needUTF8] (also:
[output to native encoding or UTF-8 in
`fwrite`][datatable_ENCODED_CHAR], [automatic conversion in
`forder`][datatable_anynotascii]). The `getCharCE` API function appeared
in R-2.7.0 together with the encoding support, so switching the
`IS_UTF8` and `IS_LATIN` macros from `LEVELS` to API calls [was
relatively straightforward][datatable_levels1].

R-4.5.0 is expected to introduce the `charIsASCII` "experimental" API
function that returns the value of the ASCII marker for a `CHARSXP`
value, which [will replace the use of `LEVELS` in the `IS_ASCII`
macro][remove_levels]. Curiously, while it looks like the code could
benefit from switching from the `getCharCE()` tests (which only look at
the value of the flags and so may needlessly translate strings from
`CE_NATIVE`) to the new experimental `charIs(UTF8|Latin1)` functions
that will also return `TRUE` for a matching native encoding, actually
making the change breaks a number of unit tests.

Growable vectors: `SETLENGTH`, `SET_GROWABLE_BIT`, `SET_TRUELENGTH`
-------------------------------------------------------------------

Over-allocated `data.table`s have been introduced in [v1.7.3, November
2011][news173]. It was a simpler time, when package code could [just set
`LENGTH(newdt) = l` and `TRUELENGTH(newdt) =
n`][datatable_overallocation] for the newly allocated `VECSXP` list.
<!-- and \if{html}{\out{tracking JavaScript}} was not a big deal -->

<!-- TODO: history of overallocated lists+names in data.table -->

Why used: need to create new columns by reference, which requires free
column and name slots

Why non-API: make a length too long and the list is broken.
<!-- TODO: Setting a length too short while having something other than
`R_NilValue` inside: does it break something? Are these values
reachable from the GC point of view? -->
<!-- TODO: the exact nature of GROWABLE_BIT -->
<!-- TODO: verify that these are the only uses of SETLENGTH,
SET_GROWABLE_BIT -->

What to do about it: reimplement in ALTREP on R &ge; 4.1

Fast string matching: `SET_TRUELENGTH`, `TRUELENGTH`
----------------------------------------------------

Why used: to exploit the `CHARSXP` cache. R interns strings, so a string
with the given contents and encoding bits exists as a single object,
even if manually recreated using `mkCharLenCE()` and friends.
Convert everything into UTF-8 and you can use pointer comparison.
Given `x` and `table` of strings to find elements of `x` in, `chmatch()`
puts indices into `table` into the `TRUELENGTH` field of the `CHARSXP`
contents of `table`, then walks `x` and reads the indices back from the
matching `CHARSXP`s, then carefully restores everything.

<!-- TODO: expand, possibly illustrate this explanation and others -->

Why non-API: this field is not always used (cf. `data.table` having to
work with it being completely uninitialised in old versions of R), but R
does use it for internal purposes sometimes (cf. `data.table` having to
restore nonzero `TRUELENGTH` for `CHARSXP` values used inside `SYMSXP`
values).

Why this is hard to fix: the current happy path is very fast.
`O(length(table)) + O(length(x))` to convert encodings,
`O(length(table))` to mark indices, `O(length(x))` to look them up,
`O(length(table))` to restore everything. Done. Pointer comparisons will
take `O(length(table)*length(x))`, which is Bad. How expensive is it to
build a hash for `O(length(table))` entries? Best case lookup will be
once again `O(length(x))`, but only without collisions, the constants
are unknown, and the C standard says that hashing pointers is fraught
with peril.

<!-- TODO: more uses of SET_TRUELENGTH for similar purposes -->

Conclusion
==========

References
==========

[is.R]: https://developer.r-project.org/blosxom.cgi/R-devel/NEWS/2024/03/08#n2024-03-09
[WRE]: https://cran.r-project.org/doc/manuals/R-exts.html
[CRANpolicy]: https://cran.r-project.org/web/packages/policies.html
[WRE33API]: https://web.archive.org/web/20160609093632/https://cran.r-project.org/doc/manuals/R-exts.html#The-R-API
[ltierney_serialize]: https://homepage.divms.uiowa.edu/~luke/R/serialize/serialize.html
[WRE45serialize]: https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Custom-serialization-input-and-output
[digest]: https://cran.r-project.org/package=digest
[WRE33wilcox]: https://web.archive.org/web/20160609093632/https://cran.r-project.org/doc/manuals/R-exts.html#Distribution-functions
[wilcox_declared]: https://github.com/r-devel/r-svn/commit/1638b0106279aa1944b17742054bc6882656596e
[wilcox_api]: https://github.com/r-devel/r-svn/commit/32ea1f67f842e3247f782a91684023b0b5eec6c5
[ALTREPnonAPI]: https://stat.ethz.ch/pipermail/r-devel/2024-April/083339.html
[ALTREP]: https://svn.r-project.org/R/branches/ALTREP/ALTREP.html
[Rd200210]: https://stat.ethz.ch/pipermail/r-devel/2002-October/thread.html
[Rd200510]: https://stat.ethz.ch/pipermail/r-devel/2005-October/thread.html
[Rd201905]: https://stat.ethz.ch/pipermail/r-devel/2019-May/thread.html
[clarifyingAPI]: https://stat.ethz.ch/pipermail/r-devel/2024-June/083449.html
[remove_non_API]: https://github.com/Rdatatable/data.table/issues/6180
[datatable_isframe_added]: https://github.com/Rdatatable/data.table/commit/87666e70ce1a69b28f0e92ec7504d80e3d53a824#diff-4fc47a9752ba4edfef0cabcc1958eda943545ad3859e48d498b0e3f87a9ae5aeR192
[R_isdataframe_added]: https://github.com/r-devel/r-svn/commit/4ef83b9dc3c6874e774195d329cbb6c11a71c414
[remove_isframe]: https://github.com/Rdatatable/data.table/issues/6244
[WRE_replacement_entrypoints]: https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Some-API-replacements-for-non_002dAPI-entry-points
[setOldClass]: https://search.r-project.org/R/refmans/methods/html/setOldClass.html
[IS_S4_OBJECT]: https://github.com/r-devel/r-svn/blob/c20ebd2d417d9ebb915e32bfb0bfdad768f9a80a/src/main/memory.c#L4033-L4035
[isS4]: https://github.com/r-devel/r-svn/blob/c20ebd2d417d9ebb915e32bfb0bfdad768f9a80a/src/main/objects.c#L1838-L1841
[asS4]: https://github.com/r-devel/r-svn/blob/c20ebd2d417d9ebb915e32bfb0bfdad768f9a80a/src/main/objects.c#L1843
[remove_set_s4_object]: https://github.com/Rdatatable/data.table/pull/6183
[call]: https://search.r-project.org/R/refmans/base/html/call.html
[WRE_call]: https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Creating-call-expressions
[remove_set_typeof]: https://github.com/Rdatatable/data.table/pull/6313
[Tierney_gengc]: https://homepage.stat.uiowa.edu/~luke/R/gengcnotes.html
[Tierney_writebr]: https://homepage.stat.uiowa.edu/~luke/R/barrier.html
[remove_string_ptr]: https://github.com/Rdatatable/data.table/pull/6312
[PR18775]: https://bugs.r-project.org/show_bug.cgi?id=18775
[Tierney_refcnt]: https://developer.r-project.org/Refcnt.html
[Rnews_setnamed]: https://developer.r-project.org/blosxom.cgi/R-devel/NEWS/2017/09/02#n2017-09-03
[remove_named]: https://github.com/Rdatatable/data.table/pull/6420/files#diff-22b103646a1efab9bbfc374791ccfc3fd1422eefc48918a3e126fc2f30d1f572L552
[LEVELS_macro]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L228
[LEVELS_function]:https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/memory.c#L3902
[LEVELS_field]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L132
[gp_for_match1]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/match.c#L175
[gp_for_match2]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/match.c#L233-L236
[gp_for_match3]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/unique.c#L53
[gp_for_gc]:https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/memory.c#L151-L155
[gp_for_finalize]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/memory.c#L1364-L1374
[gp_for_calling]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/errors.c#L1660-L1665
[gp_for_assignment]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L280-L324
[gp_for_s4]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L359-L362
[gp_for_jit]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L364-L371
[gp_for_growable]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L373-L377
[gp_for_missing]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L449-L456
[gp_for_missing2]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/eval.c#L2260-L2281
[gp_for_ddval]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L519-L523
[Rhelp_dots]: https://search.r-project.org/R/refmans/base/html/dots.html
[gp_for_env]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L529-L530
[envflags_locked]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/envir.c#L106-L108
[envflags_global]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/envir.c#L613-L655
[gp_for_hashash]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L1182-L1186
[hashash2]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/envir.c#L517-L520
[gp_for_active]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L1205-L1210
[active_binding]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/envir.c#L3466-L3483
[gp_for_basesym]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L1225-L1228
[basesym2]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/main/envir.c#L754-L768
[gp_for_special]: https://github.com/r-devel/r-svn/blob/2753df314f7d8e154bc42b5abd99daaf6472dbe1/src/include/Defn.h#L1230-L1236
[specialsym2]: https://github.com/r-devel/r-svn/blob/2753df314f7d8e154bc42b5abd99daaf6472dbe1/src/main/names.c#L1019-L1046
[gp_for_promsxp]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L1165-L1166
[gp_for_charsxp]: https://github.com/r-devel/r-svn/blob/c9437a83b9677074fe01310caac6a2a66cc7f680/src/include/Defn.h#L843-L853
[R_Encoding]: https://search.r-project.org/R/refmans/base/html/Encoding.html
[WRE_Encoding]: https://cran.r-project.org/doc/manuals/R-exts.html#Character-encoding-issues
[R_SET_ASCII]: https://github.com/r-devel/r-svn/blob/2753df314f7d8e154bc42b5abd99daaf6472dbe1/src/main/envir.c#L4312-L4375
[datatable_isencoded]: https://github.com/Rdatatable/data.table/blob/40ad2e6978202ecc626db9eaae3a18ed5e4df769/src/data.table.h#L36-L38
[datatable_needUTF8]: https://github.com/Rdatatable/data.table/blob/40ad2e6978202ecc626db9eaae3a18ed5e4df769/src/data.table.h#L63-L73
[datatable_ENCODED_CHAR]: https://github.com/Rdatatable/data.table/blob/40ad2e6978202ecc626db9eaae3a18ed5e4df769/src/fwriteR.c#L8-L12
[datatable_anynotascii]: https://github.com/Rdatatable/data.table/blob/40ad2e6978202ecc626db9eaae3a18ed5e4df769/src/forder.c#L312-L331
[datatable_levels1]: https://github.com/Rdatatable/data.table/pull/6420/commits/46dbfa93e72776c59dacb286de9831fa28c481b5#diff-3b83136e49e2df4f5df80b312d7d4199fed9e0d283401dbf7bd9159a5096bcaaL36
[remove_levels]: https://github.com/Rdatatable/data.table/pull/6422/commits/72cbd170fd16844dd8094b8d049d2e56d0926d22
[news173]: https://github.com/Rdatatable/data.table/blob/6a15f8617de121a406cee97b22e83e0c2c4bb034/NEWS.0.md#new-features-13
[datatable_overallocation]: https://github.com/Rdatatable/data.table/commit/e09d91beccc862eebcd9497c27b422058320396b#diff-22b103646a1efab9bbfc374791ccfc3fd1422eefc48918a3e126fc2f30d1f572R262-R276
