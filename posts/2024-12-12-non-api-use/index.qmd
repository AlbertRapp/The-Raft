---
title: "Use of non-API functions in `data.table`"
author: "Ivan Krylov"
date: "2024-12-12"
categories: [code]
# image: "image.jpg"
draft: true
bibliography: refs.bib
---

```{r}
#| echo: false
library(data.table)
library(tools) # format.check_details
load('precomputed.rda')
```

In the late 1970's, people at Bell Laboratories designed the S
programming language in order to facilitate interactive exploratory data
analysis [@Chambers2016]. Instead of writing, compiling, scheduling, and
interpreting the output of individual Fortran programs, the goal of S
was to conduct all the necessary steps of the analysis on the fly. S
achieved this not by replacing the extensive collection of Fortran
subroutines, but by providing a special interface language [@Becker1985]
through which S could communicate with compiled code.

Fast forward more than four decades and an increase by more than three
orders of magnitude in storage and processing capability of computers
around us. The [dominant implementation of S is now R][is.R]. It is now
feasible to implement algorithms solely in R, recouping the potential
performance losses in performance by reducing the programmer effort
spent debugging and maintaining the code [@Nash2024]. Still, the
capability of R to be extended by special-purpose compiled code is as
important as ever. As of `r when`,
`r with(cpdb, round(sum(NeedsCompilation=='yes')/length(NeedsCompilation)*100))`%
of CRAN packages use compiled code. Since the implementation language of
R is C, not Fortran, the programming interface for R is also defined in
terms of C.

What's in an API?
=================

[Writing R Extensions][WRE] ("WRE") is the definitive guide for R
package development. Together with the [CRAN policy][CRANpolicy] it
forms the "rules as written" that the maintainers of CRAN packages must
follow. A recent version of R exports `r nrow(symbols)` symbols,
including `r symbols[,sum(type=='function')]` functions ("entry points",
not counting C preprocessor macros) and
`r symbols[,sum(type!='function')]` variables. Not all of them are
intended to be used by packages. Even back in R-3.3.0, the oldest
version currently supported by `data.table`, [WRE chapter 6, "The R
API"][WRE33API] classified R's entry points into four categories:

> * __API__
>   Entry points which are documented in this manual and declared in an
>   installed header file. These can be used in distributed packages and
>   will only be changed after deprecation.
> * __public__
>   Entry points declared in an installed header file that are exported
>   on all R platforms but are not documented and subject to change
>   without notice.
> * __private__
>   Entry points that are used when building R and exported on all R
>   platforms but are not declared in the installed header files. Do not
>   use these in distributed code.
> * __hidden__
>   Entry points that are where possible (Windows and some modern
>   Unix-alike compilers/loaders when using R as a shared library) not
>   exported.

Although nobody objected to the use of the _API_ entry points, and there
was little point in trying to use the _hidden_ entry points in a package
that would fail to link almost everywhere, the _public_ and the
_private_ entry points ended up being a point of contention. Those
deemed too internal to use but not feasible to make _hidden_ were (and
still are) listed in the character vector `tools:::nonAPI`: ` R CMD
check ` looks at the functions imported by the package and signals a
`NOTE` if it finds any listed there.

The remaining _public_ functions, neither documented as API nor
explicitly forbidden by ` R CMD check `, sat there, alluring the package
developers with their offers. For example, the [serialization
interface][ltierney_serialize] is only [documented in WRE since
R-4.5][WRE45serialize], but it has been powering the [fastdigest] CRAN
package since 2015 at the latest, the maintainer having successfully
gambled on it not to change too drastically. Some of the inclusions in
`tools:::nonAPI` could have been historical mistakes: while WRE has been
saying [back in version 3.3.0][WRE33wilcox] that `wilcox_free` should be
called after a call to the (API) functions `dwilcox`, `pwilcox` or
`qwilcox`, the function was only [declared in the public
headers][wilcox_declared] and [removed from
`tools:::nonAPI`][wilcox_api] in R-4.2.0. Still, between R-3.3.3 and
R-4.4.2, `tools:::nonAPI` grew from `r length(nonAPI.3_3)` to
`r length(nonAPI.4_4)` entries, and the package maintainers had to adapt
or face archival of their packages.

A [recent question on R-devel][ALTREPnonAPI] (whether the [ALTREP]
interface should be considered "API" for the purpose of CRAN package
developent) sparked a series of events and an extensive discussion
containing the highest count of occurrences of the word "API" per month
ever seen on R-devel (234), topping [October 2002][Rd200210] (package
versioning and API breakage, 150), [October 2005][Rd200510] (API for
graphical interfaces and console output, 124), and [May 2019][Rd201905]
(discussions of the ALTREP interface and multi-threading, 121). As a
result, Luke Tierney [started work][clarifyingAPI] on programmatically
describing the functions and other symbols exported by R (including
variables and preprocessor and enumeriation constants), giving a
stronger definition to the interface. His changes add the currently
unexported function `tools:::funAPI()` that lists entry points and two
more of their categories:

> * __experimental__
>   Entry points declared in an installed header file that are part of
>   an experimental API, such as `R_ext/Altrep.h`. These are subject to
>   change, so package authors wishing to use these should be prepared
>   to adapt.
> * __embedding__
>   Entry points intended primarily for embedding and creating new
>   front-ends. It is not clear that this needs to be a separate
>   category but it may be useful to keep it separate for now.

Additionally, WRE now spells out that entry points not explicitly
documented or at least listed in the output of `tools:::funAPI` (or
something that will replace it) are now off-limits, even if not
currently present in `tools:::nonAPI` (emphasis added):

> * __public__
>   Entry points declared in an installed header file that are exported
>   on all R platforms but are not documented and subject to change
>   without notice. _Do not use these in distributed code. Their
>   declarations will eventually be moved out of installed header
>   files._

<!-- MAYBE: mention Rf_ remapping and typical APIs look like at some
point -->

<!-- MAYBE: how did Rinternals change since 3.3.0? USE_RINTERNALS is
gone -->

<!-- MAYBE: somehow obtain the list of imports (mirror Windows builds
from CRAN? download the one compiled by Luke Tierney?) and try to
extract neither-official-API nor-official-nonAPI counts -->

<!-- MAYBE: see which listed non-API functions are the most "popular" in
packages still on CRAN -->

Use of non-API entry points in `data.table`
===========================================

The first version of the `data.table` package in the CRAN archive dates
back to April 2006 (which corresponds to R version 2.3.0). It has been
evolving together with R and its API and thus has accumulated a number
of uses of R internals that are [no longer considered part of the
API][remove_non_API]:

`r gsub(
 '(?m)^', '>     ', perl = TRUE,
 format(subset(checks, grepl('API', Output))[1,])
)`

 -- ` R CMD check --as-cran ` on a released version of `data.table`

Testing for a `data.frame`: `isFrame`
-------------------------------------

Back in 2012, Matt Dowle needed to quickly test an object for being a
`data.frame`, and the undocumented function `isFrame` seemed like it
[did the job][datatable_isframe_added]. Since `isFrame` was not part of
the documented API, in 2024 Luke Tierney gave the function a
better-fitting name, [`isDataFrame`][R_isdataframe_added], and made it
an experimental API, while retaining the original function as a wrapper.

Use of `isFrame` [doesn't give a `NOTE` yet][remove_isframe], but when
R-4.5.0 is released together with the new name for the function,
`data.table` will be able to use it, falling back to `isFrame` on older
versions of R. `isDataFrame` is documented among other [replacement
entry point names][WRE_replacement_entrypoints] in Writing R Extensions.

Operating on the S4 bit: `IS_S4_OBJECT`, `SET_S4_OBJECT`, `UNSET_S4_OBJECT`
---------------------------------------------------------------------------

The `data.table` class is [registered][setOldClass] with the S4 OOP
system, making it possible to create S4 classes containing `data.table`s
as members (`setClass(slots = c(mytable = 'data.table'))`) or even
inheriting from `data.table` (and, in turn, from `data.frame`:
`setClass(contains = 'data.table')`). This latter case requires care
from the C code: when creating a copy of an S4 `data.table` from scratch
(or setting all attributes from one object onto another), the
destination value must also end up being an S4 object. This is
controlled by the special "S4" bit in the header of every R object, so
the code must read and set it correctly. <!-- MAYBE: say and link where
exacly data.table does this -->

The undocumented functions `IS_S4_OBJECT`, `SET_S4_OBJECT`,
`UNSET_S4_OBJECT` exist as bare interfaces to [the internal
macros][IS_S4_OBJECT] of the same names and directly access the flag
inside their argument.

The [`Rf_isS4`][isS4] function is a wrapper for `IS_S4_OBJECT` that
follows the usual naming convention for remapped functions, has been
part of the API for a long time, and could implement additional checks
if they are needed by R. The [`Rf_asS4`][asS4] function (experimental
API) is more involved, making sure to operate on a shallow copy of an
object instead of overwriting it in place and trying to "deconstruct" S4
objects into S3 objects if possible and requested.

Solution: [use `Rf_isS4` instead of
`IS_S4_OBJECT`][remove_set_s4_object], as
[documented][WRE_replacement_entrypoints] in Writing R Extensions. Use
`Rf_asS4` to control the S4 object bit, but be careful <!--how?-->
around shared objects.

Converting between calls and pairlists: `SET_TYPEOF`
----------------------------------------------------

In R, [function calls][call] are internally represented as Lisp-style
pairlists where the first pair is of special type `LANGSXP` instead of
`LISTSXP`. For example, the following diagram illustrates the data
structure of the call `print(x = 42L)`:

![](langsxp.svg){width=40em}

Here, every list item is a separate R object, a "cons cell"; each cell
contains the value in its `CAR` field and a reference to the rest of the
list in its `CDR` field. Argument names, if provided, are stored in the
third field, `TAG`.  The list is terminated by `R_NilValue`, which is of
type `NILSXP`. These structures must be constructed every time C code
wants to evaluate a function call. <!-- MAYBE: say and link where
exacly data.table does this -->

Previously, R API contained a function to allocate `LISTSXP` pairlists
of arbitrary length, `allocList()`, but not function calls, so it became
a somewhat common idiom to first allocate the list and then use
`SET_TYPEOF` to change the type of the head pair to `LANGSXP`. This
did not immediately break, since the two types have the same internal
memory layout.

The danger of `SET_TYPEOF` lies in the possibility to set the type of an
R value to one with an incompatible memory layout. (For example, vector
types `REALSXP` and `INTSXP` are built very differently from cons cells
`LISTSXP` and `LANGSXP`.) Starting with R-4.4.1, [R contains the
`allocLang` function in addition to the `allocList` function][WRE511]
that directly allocates a function call object with a head pair of type
`LANGSXP`. In order to stay compatible with previous R versions,
packages may [allocate the `LISTSXP` tail first and then use `lcons()`
to construct the `LANGSXP` head pair of the call][remove_set_typeof].

Strings as C arrays of `CHARSXP` values: `STRING_PTR`
-----------------------------------------------------

<!-- TODO: Why used -->

[Fixed in git][remove_string_ptr] by switching to `STRING_PTR_RO`,
present on CRAN for now.

Why non-API: writes to arrays of `SEXP` values *must* go through the
write barrier for GC to work, hence the need for `SET_STRING_ELT` and
`SET_VECTOR_ELT`. Also, R assumes that `STRSXP` vectors only contain
`CHARSXP` values, and a writeable pointer is an invitation to violate
that assumption.

See also: [PR18775]

Reading the reference counts: `NAMED`
-------------------------------------

[#6420][remove_named]

Encoding bits: `LEVELS`
-----------------------

[Waiting for R-4.5.0 to release with the new API][remove_levels]

Why used: need to know the encoding. Distinguish between `CE_UTF8` and
string actually in UTF-8 (can also happen with `CE_NATIVE` in a UTF-8
locale)

<!-- TODO: how exactly is the check implemented in data.table and which
APIs R offers for this purpose -->
<!-- TODO: examples of why exactly LEVELS is deep internal sorcery -->
<!-- TODO: LEVELS live inside serialized data, which R will have to keep
being able to read -->

Growable vectors: `SETLENGTH`, `SET_GROWABLE_BIT`, `SET_TRUELENGTH`
-------------------------------------------------------------------

Introduced in [v1.7.3, November 2011][news173].

<!-- TODO: history of overallocated lists+names in data.table -->

Why used: need to create new columns by reference, which requires free
column and name slots

Why non-API: make a length too long and the list is broken.
<!-- TODO: Setting a length too short while having something other than
`R_NilValue` inside: does it break something? Are these values
reachable from the GC point of view? -->
<!-- TODO: the exact nature of GROWABLE_BIT -->
<!-- TODO: verify that these are the only uses of SETLENGTH,
SET_GROWABLE_BIT -->

What to do about it: reimplement in ALTREP on R &ge; 4.1

Fast string matching: `SET_TRUELENGTH`, `TRUELENGTH`
----------------------------------------------------

Why used: to exploit the `CHARSXP` cache. R interns strings, so a string
with the given contents and encoding bits exists as a single object,
even if manually recreated using `mkCharLenCE()` and friends.
Convert everything into UTF-8 and you can use pointer comparison.
Given `x` and `table` of strings to find elements of `x` in, `chmatch()`
puts indices into `table` into the `TRUELENGTH` field of the `CHARSXP`
contents of `table`, then walks `x` and reads the indices back from the
matching `CHARSXP`s, then carefully restores everything.

<!-- TODO: expand, possibly illustrate this explanation and others -->

Why non-API: this field is not always used (cf. `data.table` having to
work with it being completely uninitialised in old versions of R), but R
does use it for internal purposes sometimes (cf. `data.table` having to
restore nonzero `TRUELENGTH` for `CHARSXP` values used inside `SYMSXP`
values).

Why this is hard to fix: the current happy path is very fast.
`O(length(table)) + O(length(x))` to convert encodings,
`O(length(table))` to mark indices, `O(length(x))` to look them up,
`O(length(table))` to restore everything. Done. Pointer comparisons will
take `O(length(table)*length(x))`, which is Bad. How expensive is it to
build a hash for `O(length(table))` entries? Best case lookup will be
once again `O(length(x))`, but only without collisions, the constants
are unknown, and the C standard says that hashing pointers is fraught
with peril.

<!-- TODO: more uses of SET_TRUELENGTH for similar purposes -->

Conclusion
==========

References
==========

[is.R]: https://developer.r-project.org/blosxom.cgi/R-devel/NEWS/2024/03/08#n2024-03-09
[WRE]: https://cran.r-project.org/doc/manuals/R-exts.html
[CRANpolicy]: https://cran.r-project.org/web/packages/policies.html
[WRE33API]: https://web.archive.org/web/20160609093632/https://cran.r-project.org/doc/manuals/R-exts.html#The-R-API
[ltierney_serialize]: https://homepage.divms.uiowa.edu/~luke/R/serialize/serialize.html
[WRE45serialize]: https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Custom-serialization-input-and-output
[fastdigest]: https://cran.r-project.org/package=fastdigest
[WRE33wilcox]: https://web.archive.org/web/20160609093632/https://cran.r-project.org/doc/manuals/R-exts.html#Distribution-functions
[wilcox_declared]: https://github.com/r-devel/r-svn/commit/1638b0106279aa1944b17742054bc6882656596e
[wilcox_api]: https://github.com/r-devel/r-svn/commit/32ea1f67f842e3247f782a91684023b0b5eec6c5
[ALTREPnonAPI]: https://stat.ethz.ch/pipermail/r-devel/2024-April/083339.html
[ALTREP]: https://svn.r-project.org/R/branches/ALTREP/ALTREP.html
[Rd200210]: https://stat.ethz.ch/pipermail/r-devel/2002-October/thread.html
[Rd200510]: https://stat.ethz.ch/pipermail/r-devel/2005-October/thread.html
[Rd201905]: https://stat.ethz.ch/pipermail/r-devel/2019-May/thread.html
[clarifyingAPI]: https://stat.ethz.ch/pipermail/r-devel/2024-June/083449.html
[remove_non_API]: https://github.com/Rdatatable/data.table/issues/6180
[datatable_isframe_added]: https://github.com/Rdatatable/data.table/commit/87666e70ce1a69b28f0e92ec7504d80e3d53a824#diff-4fc47a9752ba4edfef0cabcc1958eda943545ad3859e48d498b0e3f87a9ae5aeR192
[R_isdataframe_added]: https://github.com/r-devel/r-svn/commit/4ef83b9dc3c6874e774195d329cbb6c11a71c414
[remove_isframe]: https://github.com/Rdatatable/data.table/issues/6244
[WRE_replacement_entrypoints]: https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Some-API-replacements-for-non_002dAPI-entry-points
[setOldClass]: https://search.r-project.org/R/refmans/methods/html/setOldClass.html
[IS_S4_OBJECT]: https://github.com/r-devel/r-svn/blob/c20ebd2d417d9ebb915e32bfb0bfdad768f9a80a/src/main/memory.c#L4033-L4035
[isS4]: https://github.com/r-devel/r-svn/blob/c20ebd2d417d9ebb915e32bfb0bfdad768f9a80a/src/main/objects.c#L1838-L1841
[asS4]: https://github.com/r-devel/r-svn/blob/c20ebd2d417d9ebb915e32bfb0bfdad768f9a80a/src/main/objects.c#L1843
[remove_set_s4_object]: https://github.com/Rdatatable/data.table/pull/6183
[call]: https://search.r-project.org/R/refmans/base/html/call.html
[WRE511]: https://cran.r-project.org/doc/manuals/R-exts.html#Evaluating-R-expressions-from-C
[remove_set_typeof]: https://github.com/Rdatatable/data.table/pull/6313
[remove_string_ptr]: https://github.com/Rdatatable/data.table/pull/6312
[PR18775]: https://bugs.r-project.org/show_bug.cgi?id=18775
[remove_named]: https://github.com/Rdatatable/data.table/pull/6420
[remove_levels]: https://github.com/Rdatatable/data.table/pull/6422
[news173]: https://github.com/Rdatatable/data.table/blob/6a15f8617de121a406cee97b22e83e0c2c4bb034/NEWS.0.md#new-features-13
